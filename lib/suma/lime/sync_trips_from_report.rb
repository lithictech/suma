# frozen_string_literal: true

require "suma/lime"
require "suma/mobility/trip_importer"

# Sync trips from the Lime CSV report they provide partners.
class Suma::Lime::SyncTripsFromReport
  include Appydays::Loggable

  DEFAULT_VEHICLE_TYPE = Suma::Mobility::ESCOOTER
  CUTOFF = 2.weeks

  TRIP_TOKEN = "TRIP_TOKEN"
  START_TIME = "START_TIME"
  END_TIME = "END_TIME"
  USER_EMAIL = "USER_EMAIL"
  START_LATITUDE = "START_LATITUDE"
  START_LONGITUDE = "START_LONGITUDE"
  END_LATITUDE = "END_LATITUDE"
  END_LONGITUDE = "END_LONGITUDE"
  COST_TO_SUMA = "COST_TO_SUMA"
  LIME_ACCESS_COST = "LIME_ACCESS_COST"

  def row_iterator = Suma::Webhookdb::RowIterator.new("lime/synctripsreport/pk")

  def run
    ds = self.dataset
    ds = ds.select(:pk, Sequel.pg_jsonb(:data).get("Attachments").as(:attachments))
    self.row_iterator.each(ds) do |row|
      row.fetch(:attachments).each do |attachment|
        content_type = attachment.fetch("ContentType")
        next unless content_type == "text/csv"
        b64content = attachment.fetch("Content")
        content = Base64.decode64(b64content)
        self.run_for_report(content, filename: attachment.fetch("Name", nil))
      end
    end
  end

  def dataset
    ds = Suma::Webhookdb.postmark_inbound_messages_dataset.
      where(Sequel.lit("from_email SIMILAR TO ?", Suma::Lime.trip_report_from_email)).
      where(to_email: Suma::Lime.trip_report_to_email).
      where { timestamp > CUTOFF.ago }
    return ds
  end

  def run_for_report(txt, filename: nil)
    csv = CSV.parse(txt, headers: true)
    csv.each do |row|
      # Spreadsheets are machine generated by weird machines that are including a lot of extra rows,
      # and sometimes rows are missing columns.
      # We can't really predict these reliably, so if the trip token or email is missing,
      # assume the row is broken and just skip it.
      trip_token = row[TRIP_TOKEN]
      user_email = row[USER_EMAIL]
      next if trip_token.blank? || user_email.blank?
      # Ignore older spreadsheets, not worth supporting them.
      unless row[LIME_ACCESS_COST]
        self.logger.warn("lime_report_invalid_csv", filename:)
        Sentry.capture_message("Lime trip report with invalid headers") do |scope|
          scope.set_extras(filename:, headers: row.headers)
        end
        # Break instead of processing the next row.
        break
      end
      reg_ds = Suma::AnonProxy::VendorAccountRegistration.where(
        account: Suma::AnonProxy::VendorAccount.where(configuration_id: Suma::Lime.trip_report_vendor_configuration_id),
        external_program_id: user_email,
      )
      if reg_ds.empty?
        args = {member_contact_email: user_email, trip_token:, filename:}
        self.logger.warn("lime_report_missing_member", args)
        Sentry.capture_message("Lime trip taken by unknown user") do |scope|
          scope.set_extras(args)
        end
        next
      end
      if (existing = Suma::Mobility::Trip[external_trip_id: trip_token])
        # If we already have this trip recorded, we want to noop, or update it if configured.
        # We do NOT handle the race condition with a unique violation on external_trip_id,
        # since in that case we assume we're dealing with the same code and it isn't worth the complexity.
        if Suma::Lime.trip_report_overwrite
          new_values = self.parse_trip_from_row(row)[:receipt]
          existing.update(new_values.trip.values)
        end
        next
      end
      self.import_trip_from_row(row)
    end
  end

  def parse_trip_from_row(row)
    registration = Suma::AnonProxy::VendorAccountRegistration.find!(external_program_id: row.fetch(USER_EMAIL))
    vendor_config = registration.account.configuration
    program = Suma::Enumerable.one!(vendor_config.programs)
    pricing = Suma::Enumerable.one!(program.pricings)
    receipt = self.parse_row_to_receipt(row, rate: pricing.vendor_service_rate)
    receipt.trip.set(
      member: registration.account.member,
      vendor_service: pricing.vendor_service,
      vendor_service_rate: pricing.vendor_service_rate,
    )
    return {receipt:, program:}
  end

  def import_trip_from_row(row)
    r = self.parse_trip_from_row(row)
    Suma::Mobility::TripImporter.import(receipt: r[:receipt], program: r[:program], logger: self.logger)
  end

  # Convert a CSV row into a receipt for trip import.
  # Note that we use our own rates for all Lime pricing;
  # using anonymous accounts means we resemble a flow much more like
  # suma retailing Lime trips.
  #
  # The only price column we keep track of is ACTUAL_COST;
  # this is what Lime charges suma.
  def parse_row_to_receipt(row, rate:)
    r = Suma::Mobility::TripImporter::Receipt.new
    r.trip.set(
      vehicle_id: row.fetch(TRIP_TOKEN),
      vehicle_type: DEFAULT_VEHICLE_TYPE,
      began_at: parsetime(row.fetch(START_TIME)),
      ended_at: parsetime(row.fetch(END_TIME)),
      begin_lat: BigDecimal(row.fetch(START_LATITUDE)),
      begin_lng: BigDecimal(row.fetch(START_LONGITUDE)),
      end_lat: BigDecimal(row.fetch(END_LATITUDE)),
      end_lng: BigDecimal(row.fetch(END_LONGITUDE)),
      external_trip_id: row.fetch(TRIP_TOKEN),
      our_cost: Monetize.parse(row.fetch(COST_TO_SUMA)),
    )
    r.charged_at = r.trip.began_at
    r.paid_off_platform_amount = Money.zero
    r.subsidized_off_platform_amount = Money.zero

    if Monetize.parse(row.fetch(LIME_ACCESS_COST)).zero?
      # If Lime wrote off the charge, it's because the ride was canceled (too short, didn't move, etc.).
      # We do NOT want to charge, or claim we charged, the user anything in this case.
      r.undiscounted_subtotal = Money.zero
      r.misc_line_items << Suma::Mobility::EndTripResult::LineItem.new(
        memo: Suma::I18n::StaticString.find_text("backend", "trip_receipt_ride_canceled"),
        amount: Money.zero,
      )
    else
      r.undiscounted_subtotal = rate.calculate_undiscounted_total(r.trip.duration_minutes)
      r.unlock_fee = rate.surcharge
      r.per_minute_fee = rate.unit_amount
    end
    return r
  end

  # Lime's time formats are ridiculous.
  # We perform our own time parsing, since the alternatives around being clever
  # or making assumptions are even worse.
  # We see a mixture of AM/PM, 12 hour clock, seconds, date formats, etc.
  # See specs for examples of all the formats we've seen.
  def parsetime(t)
    datepart, timepart = t.split(" ", 2)
    # Handle 01/31/2020 and 2020/01/31.
    datefmt = /\d\d\d\d$/.match?(datepart) ? "%m/%d/%Y" : "%Y/%m/%d"

    timeparts = timepart.split(/[: ]/)
    hr = timeparts[0].to_i
    min = timeparts[1].to_i
    if timeparts.last == "AM"
      # AM has the same hours as a 24-hour clock, except if the hour is 12, in which case that's zero.
      hr = 0 if hr == 12
    elsif timeparts.last == "PM"
      # PM could be 12 or 24-hour clock.
      hr += 12 if hr < 12
    end
    hr = hr.to_s.rjust(2, "0")
    min = min.to_s.rjust(2, "0")
    return Time.strptime("#{datepart} #{hr}:#{min} -0700", "#{datefmt} %H:%M %Z")
  end
end
