# frozen_string_literal: true

require "suma/commerce"
require "suma/postgres/model"
require "suma/admin_linked"
class Suma::Commerce::OfferingProduct < Suma::Postgres::Model(:commerce_offering_products)
  include Suma::AdminLinked

  plugin :timestamps
  plugin :money_fields, :customer_price
  plugin :money_fields, :undiscounted_price

  many_to_one :product, class: "Suma::Commerce::Product"
  many_to_one :offering, class: "Suma::Commerce::Offering"

  many_through_many :orders,
                    [
                      [:commerce_checkout_items, :offering_product_id, :checkout_id],
                    ],
                    class: "Suma::Commerce::Order",
                    right_primary_key: :checkout_id,
                    left_primary_key: :id,
                    read_only: true,
                    order: [:created_at, :id]

  dataset_module do
    # Limit and order the dataset so that:
    #
    # - There is only one offering product for each offering/product combination,
    # - The unclosed row is included, or
    # - The row with the latest closed_at is included,
    # - Rows are ordered by product ordinal and then a disambiguator
    #   (we do not order by name in our default,
    #   since that would require a translation join and in many cases we don't need it,
    #   but we could add it in the future).
    #
    # In general this should only be used with a dataset that limits for a single product or offering.
    def for_purchase
      distinct = [
        :offering_id,
        :ordinal,
        :product_id,
      ]
      return self.
          distinct(*distinct).
          reselect.
          join(:commerce_products, id: :product_id).
          order(
            # Must always order by distinct at first.
            *distinct,
            # Then we want unclosed (year 9999) or the most recently closed rows.
            Sequel.desc(Sequel.function(:coalesce, :closed_at, Sequel.cast("9999-01-01", :timestamptz))),
            # Then disambiguate.
            Sequel.desc(Sequel[:commerce_offering_products][:created_at]),
            Sequel.desc(Sequel[:commerce_offering_products][:id]),
          )
    end
  end

  def available? = self.closed_at.nil?
  alias listable? available?
  def closed? = !self.available?

  def discounted?
    return false if self.undiscounted_price.nil?
    return self.customer_price < self.undiscounted_price
  end

  def discount_amount
    return self.undiscounted_price - self.customer_price
  end

  # Create and return a new instance with one or both of the given pricing fields modified,
  # and the receiver closed. Offering product prices are immutable,
  # so this is the way we must change pricing.
  # @param customer_price [Money]
  # @param undiscounted_price [Money]
  # @param reopen_ok [true,false] If false, raise an error if this product is closed.
  #   If true, create a new opened offering product even if this product is closed.
  #   The original close timestamp is not modified.
  # @return [Suma::Commerce::OfferingProduct]
  def with_changes(customer_price: nil, undiscounted_price: nil, reopen_ok: false)
    customer_price ||= self.customer_price
    undiscounted_price ||= self.undiscounted_price
    raise Suma::InvalidPrecondition, "at least one new pricing field or reopen_ok must be passed" if
      customer_price == self.customer_price && undiscounted_price == self.undiscounted_price && !reopen_ok
    raise Suma::InvalidPrecondition, "cannot change pricing of a closed offering product" if
      !reopen_ok && self.closed?
    self.db.transaction do
      self.update(closed_at: Time.now) unless self.closed?
      return self.class.create(
        customer_price:,
        undiscounted_price:,
        offering: self.offering,
        product: self.product,
      )
    end
  end

  # Helper to use when we want to modify an offering product.
  # Should only be needed for testing.
  def update_without_validate(**)
    self.set(**)
    return self.save_changes(validate: false)
  end

  def rel_admin_link = "/offering-product/#{self.id}"

  def validate
    super
    return if self.new?
    [:customer_price_cents, :customer_price_currency].each do |col|
      errors.add(col, "cannot change customer price of offering products") if self.changed_columns.include?(col)
    end
  end
end

# Table: commerce_offering_products
# ---------------------------------------------------------------------------------------------------------------------------------------------
# Columns:
#  id                          | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at                  | timestamp with time zone | NOT NULL DEFAULT now()
#  updated_at                  | timestamp with time zone |
#  closed_at                   | timestamp with time zone |
#  product_id                  | integer                  | NOT NULL
#  offering_id                 | integer                  | NOT NULL
#  customer_price_cents        | integer                  | NOT NULL
#  customer_price_currency     | text                     | NOT NULL
#  undiscounted_price_cents    | integer                  | NOT NULL
#  undiscounted_price_currency | text                     | NOT NULL
# Indexes:
#  commerce_offering_products_pkey                         | PRIMARY KEY btree (id)
#  commerce_offering_products_product_id_offering_id_index | UNIQUE btree (product_id, offering_id) WHERE closed_at IS NULL
#  commerce_offering_products_offering_id_index            | btree (offering_id)
#  commerce_offering_products_product_id_index             | btree (product_id)
# Foreign key constraints:
#  commerce_offering_products_offering_id_fkey | (offering_id) REFERENCES commerce_offerings(id)
#  commerce_offering_products_product_id_fkey  | (product_id) REFERENCES commerce_products(id)
# Referenced By:
#  commerce_checkout_items | commerce_checkout_items_offering_product_id_fkey | (offering_product_id) REFERENCES commerce_offering_products(id)
# ---------------------------------------------------------------------------------------------------------------------------------------------
