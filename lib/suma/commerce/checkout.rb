# frozen_string_literal: true

require "suma/commerce"
require "suma/postgres/model"

class Suma::Commerce::Checkout < Suma::Postgres::Model(:commerce_checkouts)
  CONFIRMATION_EXPOSURE_CUTOFF = 2.days

  class Uneditable < StandardError; end

  plugin :timestamps
  plugin :soft_deletes

  many_to_one :cart, class: "Suma::Commerce::Cart"
  many_to_one :card, class: "Suma::Payment::Card"
  many_to_one :bank_account, class: "Suma::Payment::BankAccount"
  one_to_many :items, class: "Suma::Commerce::CheckoutItem"
  one_to_many :orders, class: "Suma::Commerce::Order"
  many_to_one :fulfillment_option, class: "Suma::Commerce::OfferingFulfillmentOption"

  def editable? = !self.soft_deleted? && !self.completed?
  def completed? = !self.completed_at.nil?
  def available_fulfillment_options = self.cart.offering.fulfillment_options
  def available_payment_instruments = self.cart.member.usable_payment_instruments

  def expose_for_confirmation?(t=Time.now)
    cutoff = t - CONFIRMATION_EXPOSURE_CUTOFF
    return self.created_at > cutoff
  end

  def complete(t=Time.now)
    self.completed_at = t
    return self
  end

  def payment_instrument
    return [self.bank_account, self.card].compact.first
  end

  def payment_instrument=(pi)
    case pi
      when nil
        self.bank_account = nil
        self.card = nil
      when Suma::Payment::BankAccount
        self.bank_account = pi
        self.card = nil
      when Suma::Payment::Card
        self.bank_account = nil
        self.card = pi
      else
        raise "Unhandled payment instrument: #{pi.inspect}"
    end
  end

  def undiscounted_cost = self.items.sum(Money.new(0), &:undiscounted_cost)
  def customer_cost = self.items.sum(Money.new(0), &:customer_cost)
  def savings = self.items.sum(Money.new(0), &:savings)
  def handling = Money.new(0)
  def taxable_cost = self.handling + self.customer_cost
  def tax = Money.new(0)
  def total = self.customer_cost + self.handling

  def create_order
    self.db.transaction do
      self.lock!
      raise Uneditable, "Checkout[#{self.id}] is not editable" unless self.editable?
      order = Suma::Commerce::Order.create(checkout: self)
      self.freeze_items
      self.cart.items_dataset.delete
      self.cart.associations.delete(:items)
      self.payment_instrument.soft_delete unless self.save_payment_instrument
      self.complete.save_changes
      return order
    end
  end

  protected def freeze_items
    self.items.each do |item|
      item.set(immutable_quantity: item.cart_item.quantity, cart_item: nil)
    end
    self.db.from(:commerce_checkout_items, :commerce_cart_items).
      where(checkout_id: self.id).
      update(cart_item_id: nil, immutable_quantity: Sequel[:commerce_cart_items][:quantity])
  end

  def after_soft_delete
    self.freeze_items
  end
end

# Table: commerce_checkouts
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Columns:
#  id                      | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at              | timestamp with time zone | NOT NULL DEFAULT now()
#  updated_at              | timestamp with time zone |
#  soft_deleted_at         | timestamp with time zone |
#  completed_at            | timestamp with time zone |
#  cart_id                 | integer                  | NOT NULL
#  bank_account_id         | integer                  |
#  card_id                 | integer                  |
#  save_payment_instrument | boolean                  | NOT NULL DEFAULT false
#  fulfillment_option_id   | integer                  | NOT NULL
# Indexes:
#  commerce_checkouts_pkey          | PRIMARY KEY btree (id)
#  commerce_checkouts_cart_id_index | UNIQUE btree (cart_id) WHERE completed_at IS NULL AND soft_deleted_at IS NULL
# Check constraints:
#  unambiguous_payment_instrument | (bank_account_id IS NOT NULL AND card_id IS NULL OR bank_account_id IS NULL AND card_id IS NOT NULL OR bank_account_id IS NULL AND card_id IS NULL)
# Foreign key constraints:
#  commerce_checkouts_bank_account_id_fkey       | (bank_account_id) REFERENCES payment_bank_accounts(id)
#  commerce_checkouts_card_id_fkey               | (card_id) REFERENCES payment_cards(id)
#  commerce_checkouts_cart_id_fkey               | (cart_id) REFERENCES commerce_carts(id)
#  commerce_checkouts_fulfillment_option_id_fkey | (fulfillment_option_id) REFERENCES commerce_offering_fulfillment_options(id)
# Referenced By:
#  commerce_checkout_items | commerce_checkout_items_checkout_id_fkey | (checkout_id) REFERENCES commerce_checkouts(id) ON DELETE CASCADE
#  commerce_orders         | commerce_orders_checkout_id_fkey         | (checkout_id) REFERENCES commerce_checkouts(id)
# -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
