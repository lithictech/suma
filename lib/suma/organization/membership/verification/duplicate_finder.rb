# frozen_string_literal: true

class Suma::Organization::Membership::Verification::DuplicateFinder
  HIGH = :high
  MED = :medium
  LOW = :low
  SIMILARITY = 0.3 # Default pg_trgm threshold, we may need to configure it

  class Match < Suma::TypedStruct
    attr_accessor :member,
                  :organization_name,
                  :verification,
                  :chance,
                  :reason

    def initialize(**)
      super
      return unless self.verification
      self.member = self.verification.membership.member
      self.organization_name = self.verification.membership.organization_label
    end
  end

  attr_reader :matches

  def initialize(verification)
    @verification = verification
    @member = @verification.membership.member
    @matches = nil
  end

  def run
    @matches = []
    search_account_numbers
    search_members
    search_addresses
    return self
  end

  def search_account_numbers
    ac = @verification.account_number
    return if ac.blank?
    sames = Suma::Organization::Membership::Verification.
      with_encrypted_value(:account_number, ac).
      exclude(id: @verification.id).
      all
    sames.each do |v|
      @matches << Match.new(verification: v, chance: HIGH, reason: :account_number)
    end
  end

  def search_members
    name_match = Sequel.function(:similarity, :name, @member.name) > SIMILARITY
    phone_match = Sequel[@member.phone => Sequel.function(:ANY, :previous_phones)]
    email_match = Sequel[@member.email => Sequel.function(:ANY, :previous_emails)]
    sames = Suma::Member.
      select_append(
        name_match.as(:name_match),
        phone_match.as(:phone_match),
        email_match.as(:email_match),
      ).
      where(name_match | phone_match | email_match).
      exclude(id: @member.id).
      all
    sames.each do |m|
      if m[:phone_match]
        reason = :phone
        chance = :high
      elsif m[:email_match]
        reason = :email
        chance = :high
      else
        chance = m.name == @member.name ? HIGH : MED
        reason = :name
      end
      @matches << Match.new(member: m, chance:, reason:)
    end
  end

  def search_addresses
    address_same = Sequel[legal_entity: Suma::LegalEntity.where(address: @member.legal_entity.address)]
    similar_address_text = Sequel.function(
      :similarity,
      @member.legal_entity.address.one_line_address,
      Sequel.function(:concat, :address1, ", ", :address2, ", ", :city, ", ", :state_or_province, ", ", :postal_code,
                      ", ", :country,),
    )
    address_similar = Sequel[
      legal_entity: Suma::LegalEntity.where(address: Suma::Address.where(similar_address_text > SIMILARITY)),
    ]
    sames_ds = Suma::Member.
      select_append(
        address_same.as(:address_same),
        address_similar.as(:address_like),
      ).
      where(address_same | address_similar).
      exclude(id: @member.id)
    sames = sames_ds.all
    sames.each do |m|
      chance = if m[:address_same]
                 HIGH
      elsif @member.legal_entity.address.address2.upcase == m.legal_entity.address.address2.upcase
        MED
      else
        LOW
      end
      @matches << Match.new(member: m, chance:, reason: :address)
    end
  end
end

# Table: organization_membership_verification_audit_logs
# -----------------------------------------------------------------------------------------------------------------------------------------------------------
# Columns:
#  id              | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  at              | timestamp with time zone | NOT NULL
#  event           | text                     | NOT NULL
#  to_state        | text                     | NOT NULL
#  from_state      | text                     | NOT NULL
#  reason          | text                     | NOT NULL DEFAULT ''::text
#  messages        | jsonb                    | NOT NULL DEFAULT '[]'::jsonb
#  verification_id | integer                  | NOT NULL
#  actor_id        | integer                  |
# Indexes:
#  organization_membership_verification_audit_logs_pkey            | PRIMARY KEY btree (id)
#  organization_membership_verification_audit_logs_verification_id | btree (verification_id)
# Foreign key constraints:
#  organization_membership_verification_audit_logs_actor_id_fkey   | (actor_id) REFERENCES members(id) ON DELETE SET NULL
#  organization_membership_verification_audit_verification_id_fkey | (verification_id) REFERENCES organization_membership_verifications(id) ON DELETE CASCADE
# -----------------------------------------------------------------------------------------------------------------------------------------------------------
