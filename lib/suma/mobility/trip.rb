# frozen_string_literal: true

require "suma/mobility"
require "suma/postgres/model"

class Suma::Mobility::Trip < Suma::Postgres::Model(:mobility_trips)
  class OngoingTrip < StandardError; end

  plugin :timestamps

  many_to_one :vendor_service, key: :vendor_service_id, class: "Suma::Vendor::Service"
  many_to_one :vendor_service_rate, key: :vendor_service_rate_id, class: "Suma::Vendor::ServiceRate"
  many_to_one :member, key: :member_id, class: "Suma::Member"
  one_to_one :charge, key: :mobility_trip_id, class: "Suma::Charge"

  dataset_module do
    def ongoing
      return self.where(ended_at: nil)
    end
  end

  def self.start_trip_from_vehicle(member:, vehicle:, rate:, at: Time.now)
    return self.start_trip(
      member:,
      vehicle_id: vehicle.vehicle_id,
      vendor_service: vehicle.vendor_service,
      rate:,
      lat: vehicle.lat,
      lng: vehicle.lng,
      at:,
    )
  end

  def self.start_trip(member:, vehicle_id:, vendor_service:, rate:, lat:, lng:, at: Time.now)
    member.read_only_mode!
    self.db.transaction(savepoint: true) do
      return self.create(
        member:,
        vehicle_id:,
        vendor_service:,
        vendor_service_rate: rate,
        begin_lat: lat,
        begin_lng: lng,
        began_at: at,
      )
    rescue Sequel::UniqueConstraintViolation => e
      raise OngoingTrip, "member #{member.id} is already in a trip" if
        e.to_s.include?("one_active_ride_per_member")
      raise
    end
  end

  def end_trip(lat:, lng:)
    # TODO: Not sure how to handle API multiple calls to a 3rd party service for the same trip,
    # or if we lose track of something (out of sync between us and service).
    # We can work this out more clearly once we have a real provider to work with.
    result = self.vendor_service.mobility_adapter.end_trip(self)
    # This would be bad, but we should know when it happens and pick up the pieces
    # instead of trying to figure out a solution to an impossible problem.
    raise Suma::InvalidPostcondition, "negative trip cost for #{self.inspect}" if result.cost_cents.negative?
    self.db.transaction do
      now = Time.now
      self.update(end_lat: lat, end_lng: lng, ended_at: result.end_time)
      # The calculated rate can be different than the service actually
      # charges us, so if we aren't using a discount, always use
      # what we end up getting actually charged.
      undiscounted_subtotal = if self.vendor_service_rate.undiscounted_rate.nil?
                                Money.new(result.cost_cents, result.cost_currency)
      else
        self.vendor_service_rate.calculate_undiscounted_total(self.rate_units)
      end
      self.charge = Suma::Charge.create(
        mobility_trip: self,
        undiscounted_subtotal:,
        member: self.member,
      )
      result_cost = Money.new(result.cost_cents, result.cost_currency)
      contributions = self.member.payment_account!.find_chargeable_ledgers(
        self.vendor_service,
        result_cost,
        now:,
        # At this point, ride has been taken and finished so we need to accept it
        # and deal with a potential negative balance.
        allow_negative_balance: true,
      )
      xactions = self.member.payment_account.debit_contributions(
        contributions,
        memo: Suma::TranslatedText.create(
          en: "Suma Mobility - #{self.vendor_service.external_name}",
          es: "Suma Movilidad - #{self.vendor_service.external_name}",
        ),
      )
      xactions.each { |x| self.charge.add_book_transaction(x) }
      return self.charge
    end
  end

  def ended?
    return !self.ended_at.nil?
  end

  def rate_units
    x = self.ended_at - self.began_at
    x /= 60
    x = x.round
    return x
  end
end

# Table: mobility_trips
# -------------------------------------------------------------------------------------------------------------------------------------------------------------
# Columns:
#  id                     | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at             | timestamp with time zone | NOT NULL DEFAULT now()
#  updated_at             | timestamp with time zone |
#  vehicle_id             | text                     | NOT NULL
#  vendor_service_id      | integer                  | NOT NULL
#  begin_lat              | numeric                  | NOT NULL
#  begin_lng              | numeric                  | NOT NULL
#  began_at               | timestamp with time zone | NOT NULL
#  end_lat                | numeric                  |
#  end_lng                | numeric                  |
#  ended_at               | timestamp with time zone |
#  vendor_service_rate_id | integer                  | NOT NULL
#  member_id              | integer                  | NOT NULL
# Indexes:
#  mobility_trips_pkey                               | PRIMARY KEY btree (id)
#  one_active_ride_per_member                        | UNIQUE btree (member_id) WHERE ended_at IS NULL
#  mobility_trips_member_id_index                    | btree (member_id)
#  mobility_trips_vehicle_id_vendor_service_id_index | btree (vehicle_id, vendor_service_id)
# Check constraints:
#  end_fields_set_together | (end_lat IS NULL AND end_lng IS NULL AND ended_at IS NULL OR end_lat IS NOT NULL AND end_lng IS NOT NULL AND ended_at IS NOT NULL)
# Foreign key constraints:
#  mobility_trips_member_id_fkey              | (member_id) REFERENCES members(id)
#  mobility_trips_vendor_service_id_fkey      | (vendor_service_id) REFERENCES vendor_services(id) ON DELETE RESTRICT
#  mobility_trips_vendor_service_rate_id_fkey | (vendor_service_rate_id) REFERENCES vendor_service_rates(id) ON DELETE RESTRICT
# Referenced By:
#  charges | charges_mobility_trip_id_fkey | (mobility_trip_id) REFERENCES mobility_trips(id) ON DELETE SET NULL
# -------------------------------------------------------------------------------------------------------------------------------------------------------------
