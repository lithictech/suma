# frozen_string_literal: true

require "suma/mobility"
require "suma/mobility/gbfs"
require "suma/postgres/model"

class Suma::Mobility::RestrictedArea < Suma::Postgres::Model(:mobility_restricted_areas)
  plugin :timestamps

  many_to_one :vendor_service, key: :vendor_service_id, class: "Suma::Vendor::Service"

  RESTRICTIONS = [
    "do-not-park",
    "do-not-ride",
    "do-not-park-or-ride",
  ].freeze

  dataset_module do
    def intersecting(ne:, sw:)
      nelat, nelng = ne
      swlat, swlng = sw
      contains_ne = Sequel.expr { (ne_lat <= nelat) & (ne_lat >= swlat) & (ne_lng <= nelng) & (ne_lng >= swlng) }
      contains_sw = Sequel.expr { (sw_lat <= nelat) & (sw_lat >= swlat) & (sw_lng <= nelng) & (sw_lng >= swlng) }
      return self.where(contains_ne | contains_sw)
    end
  end

  def bounds
    return {
      ne: [self.ne_lat, self.ne_lng],
      sw: [self.sw_lat, self.sw_lng],
    }
  end

  def bounds_numeric
    return {
      ne: [self.ne_lat.to_f, self.ne_lng.to_f],
      sw: [self.sw_lat.to_f, self.sw_lng.to_f],
    }
  end

  def multipolygon_numeric
    return self.multipolygon.map do |polygon|
      polygon.map do |ring|
        ring.map do |(x, y)|
          [x.to_f, y.to_f]
        end
      end
    end
  end

  def before_save
    # Set the bounding box to the outside boundaries of the polygons
    self.sw_lat = nil
    self.ne_lat = nil
    self.sw_lng = nil
    self.ne_lng = nil
    self.multipolygon&.each do |polygon|
      polygon.each do |pointring|
        lats, lngs = pointring.transpose
        sw_lat, ne_lat = lats.minmax
        sw_lng, ne_lng = lngs.minmax
        self.sw_lat = [self.sw_lat, sw_lat].compact.min
        self.ne_lat = [self.ne_lat, ne_lat].compact.max
        self.sw_lng = [self.sw_lng, sw_lng].compact.min
        self.ne_lng = [self.ne_lng, ne_lng].compact.max
      end
    end
    super
  end

  def validate
    super
    polygon = self.multipolygon.first&.first
    return unless polygon.present?
    if polygon.length < 4
      self.errors.add(:multipolygon, "requires at least 4 coordinates (closed triangle)")
    elsif polygon.first != polygon.last
      self.errors.add(:multipolygon, "first and last coordinate must match (closed polygon)")
    end
  end
end

# Table: mobility_restricted_areas
# ------------------------------------------------------------------------------------------------------
# Columns:
#  id                | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at        | timestamp with time zone | NOT NULL DEFAULT now()
#  updated_at        | timestamp with time zone |
#  ne_lat            | numeric                  | NOT NULL
#  ne_lng            | numeric                  | NOT NULL
#  sw_lat            | numeric                  | NOT NULL
#  sw_lng            | numeric                  | NOT NULL
#  restriction       | text                     |
#  multipolygon      | numeric[]                | NOT NULL
#  title             | text                     | NOT NULL
#  unique_id         | text                     | NOT NULL
#  vendor_service_id | integer                  | NOT NULL
# Indexes:
#  mobility_restricted_areas_pkey          | PRIMARY KEY btree (id)
#  mobility_restricted_areas_unique_id_key | UNIQUE btree (unique_id)
# Foreign key constraints:
#  mobility_restricted_areas_vendor_service_id_fkey | (vendor_service_id) REFERENCES vendor_services(id)
# ------------------------------------------------------------------------------------------------------
