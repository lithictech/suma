# frozen_string_literal: true

require "suma/admin_actions"
require "suma/admin_linked"
require "suma/external_links"
require "suma/message"
require "suma/postgres/model"

class Suma::Message::Delivery < Suma::Postgres::Model(:message_deliveries)
  include Suma::AdminLinked
  include Suma::AdminActions
  include Suma::ExternalLinks
  include Suma::Postgres::HybridSearch

  plugin :hybrid_search
  plugin :timestamps

  many_to_one :recipient, class: "Suma::Member"
  one_to_many :bodies, class: "Suma::Message::Body", order: :id

  dataset_module do
    def unsent
      return self.where(aborted_at: nil, sent_at: nil)
    end

    def to_members(members)
      emails = members.is_a?(Sequel::Dataset) ? members.select(:email) : members.map(&:email)
      return self.where(Sequel[to: emails] | Sequel[recipient: members])
    end
  end

  def initialize(*)
    super
    self[:extra_fields] ||= {}
  end

  # @return [Suma::Message::Transport]
  def transport! = Suma::Message::Transport.registry_create!(self.transport_type)
  # @return [Suma::Message::Carrier]
  def carrier! = Suma::Message::Carrier.registry_create!(self.carrier_key)
  def sensitive? = self.sensitive
  def formatted_to = self.transport!.recipient(self.to).formatted_to
  def body_with_mediatype(mt) = self.bodies.find { |b| b.mediatype == mt }

  def body_with_mediatype!(mt)
    (b = self.body_with_mediatype(mt)) or raise "Delivery #{self.id} has no body with mediatype #{mt}"
    return b
  end

  def send!
    return nil if self.sent_at || self.aborted_at
    SemanticLogger.named_tagged(message_delivery_id: self.id, to: self.to) do
      self.db.transaction do
        self.lock!
        return nil if self.sent_at || self.aborted_at
        unless self.transport!.allowlisted?(self)
          self.update(aborted_at: Time.now)
          return self
        end
        begin
          transport_message_id = self.transport!.send!(self)
        rescue Suma::Message::UndeliverableRecipient => e
          self.logger.error("undeliverable_recipient",  error: e)
          self.update(aborted_at: Time.now)
          return self
        end
        if transport_message_id.blank?
          self.logger.error("empty_transport_message_id")
          transport_message_id = "WARNING-NOT-SET"
        end
        self.update(transport_message_id:, sent_at: Time.now)
        return self
      end
    end
  end

  # Use external logs only if the message is less than 30 days old.
  # Many carriers will remove external resources after a while,
  # and anyway, this archival data should be useful for admins.
  def _use_external_logs? = self.sent_at.present? && self.sent_at > 30.days.ago

  def _external_links_self
    return [] unless self._use_external_logs?
    url = self.carrier!.external_link_for(self.carrier!.decode_message_id(self.transport_message_id))
    return [] unless url
    return [
      self._external_link("View in #{self.carrier_key.humanize}", url),
    ]
  end

  def _admin_actions_self
    return [] unless self._use_external_logs? && self.carrier!.can_fetch_details?
    return [
      self._admin_action(
        "View #{self.carrier_key.humanize} details",
        "/adminapi/v1/message_deliveries/#{self.id}/external_details",
      ),
    ]
  end

  def rel_admin_link = "/message/#{self.id}"

  def hybrid_search_fields
    return [
      :template,
      :transport_type,
      :carrier_key,
      :transport_message_id,
      :to,
      :recipient,
      :template_language,
    ]
  end

  def self.lookup_template_class(name)
    constname = name.split("::").map(&:camelize).join("::")
    fqn = "Suma::Messages::#{constname}"
    begin
      return fqn.constantize
    rescue NameError
      raise Suma::Message::MissingTemplateError, "#{fqn} not found"
    end
  end

  def self.preview(template_class_name, transport:, rack_env: Suma::RACK_ENV, commit: false, language: nil)
    raise "Can only preview in development" unless rack_env == "development"

    pattern = File.join(Pathname(__FILE__).dirname.parent, "messages", "*.rb")
    Gem.find_files(pattern).each do |path|
      require path
    end

    template_class = self.lookup_template_class(template_class_name)

    require "suma/fixtures"
    Suma::Fixtures.load_all

    delivery = nil
    self.db.transaction(rollback: commit ? nil : :always) do
      to = Suma::Fixtures.member.create
      template = template_class.fixtured(to)
      template.language = language if language
      SequelTranslatedText.language(language) do
        delivery = template.dispatch(to, transport:)
      end
      delivery.bodies # Fetch this ahead of time so it is there after rollback
    end
    return delivery
  end
end

# Table: message_deliveries
# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Columns:
#  id                   | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at           | timestamp with time zone | NOT NULL DEFAULT now()
#  updated_at           | timestamp with time zone |
#  template             | text                     | NOT NULL
#  transport_type       | text                     | NOT NULL
#  carrier_key          | text                     | NOT NULL
#  transport_message_id | text                     |
#  to                   | text                     | NOT NULL
#  recipient_id         | integer                  |
#  extra_fields         | jsonb                    | NOT NULL DEFAULT '{}'::jsonb
#  sent_at              | timestamp with time zone |
#  aborted_at           | timestamp with time zone |
#  template_language    | text                     | NOT NULL DEFAULT ''::text
#  search_content       | text                     |
#  search_embedding     | vector(384)              |
#  search_hash          | text                     |
#  sensitive            | boolean                  | NOT NULL DEFAULT false
# Indexes:
#  message_deliveries_pkey                          | PRIMARY KEY btree (id)
#  message_deliveries_transport_message_id_key      | UNIQUE btree (transport_message_id)
#  message_deliveries_recipient_id_index            | btree (recipient_id)
#  message_deliveries_search_content_tsvector_index | gin (to_tsvector('english'::regconfig, search_content))
#  message_deliveries_sent_at_index                 | btree (sent_at)
# Foreign key constraints:
#  message_deliveries_recipient_id_fkey | (recipient_id) REFERENCES members(id) ON DELETE SET NULL
# Referenced By:
#  anon_proxy_vendor_account_messages | anon_proxy_vendor_account_messages_outbound_delivery_id_fkey | (outbound_delivery_id) REFERENCES message_deliveries(id)
#  member_reset_codes                 | member_reset_codes_message_delivery_id_fkey                  | (message_delivery_id) REFERENCES message_deliveries(id)
#  message_bodies                     | message_bodies_delivery_id_fkey                              | (delivery_id) REFERENCES message_deliveries(id) ON DELETE CASCADE
# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------
