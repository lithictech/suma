# frozen_string_literal: true

require "suma/postgres/model"

require "suma/message"

class Suma::Message::Delivery < Suma::Postgres::Model(:message_deliveries)
  plugin :timestamps

  many_to_one :recipient, class: "Suma::Member"
  one_to_many :bodies, class: "Suma::Message::Body"

  dataset_module do
    def unsent
      return self.where(aborted_at: nil, sent_at: nil)
    end

    def to_members(members)
      emails = members.is_a?(Sequel::Dataset) ? members.select(:email) : members.map(&:email)
      return self.where(Sequel[to: emails] | Sequel[recipient: members])
    end
  end

  def initialize(*)
    super
    self[:extra_fields] ||= {}
  end

  def body_with_mediatype(mt)
    return self.bodies.find { |b| b.mediatype == mt }
  end

  def body_with_mediatype!(mt)
    (b = self.body_with_mediatype(mt)) or raise "Delivery #{self.id} has no body with mediatype #{mt}"
    return b
  end

  def send!
    return nil if self.sent_at || self.aborted_at
    self.db.transaction do
      self.lock!
      return nil if self.sent_at || self.aborted_at
      unless self.transport.allowlisted?(self)
        self.update(aborted_at: Time.now)
        return self
      end
      begin
        transport_message_id = self.transport.send!(self)
      rescue Suma::Message::Transport::UndeliverableRecipient => e
        self.logger.error("undeliverable_recipient", message_delivery_id: self.id, error: e)
        self.update(aborted_at: Time.now)
        return self
      end
      if transport_message_id.blank?
        self.logger.error("empty_transport_message_id", message_delivery_id: self.id)
        transport_message_id = "WARNING-NOT-SET"
      end
      self.update(transport_message_id:, sent_at: Time.now)
      return self
    end
  end

  def transport
    return Suma::Message::Transport.for(self.transport_type)
  end

  def transport!
    return Suma::Message::Transport.for!(self.transport_type)
  end

  def self.lookup_template_class(name)
    constname = name.split("::").map(&:camelize).join("::")
    fqn = "Suma::Messages::#{constname}"
    begin
      return fqn.constantize
    rescue NameError
      raise Suma::Message::MissingTemplateError, "#{fqn} not found"
    end
  end

  def self.preview(template_class_name, transport: :sms, rack_env: Suma::RACK_ENV, commit: false, language: nil)
    raise "Can only preview in development" unless rack_env == "development"

    pattern = File.join(Pathname(__FILE__).dirname.parent, "messages", "*.rb")
    Gem.find_files(pattern).each do |path|
      require path
    end

    template_class = self.lookup_template_class(template_class_name)

    require "suma/fixtures"
    Suma::Fixtures.load_all

    delivery = nil
    self.db.transaction(rollback: commit ? nil : :always) do
      to = Suma::Fixtures.member.create
      template = template_class.fixtured(to)
      template.language = language if language
      delivery = template.dispatch(to, transport:)
      delivery.bodies # Fetch this ahead of time so it is there after rollback
    end
    return delivery
  end
end

# Table: message_deliveries
# ---------------------------------------------------------------------------------------------------------------------
# Columns:
#  id                   | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at           | timestamp with time zone | NOT NULL DEFAULT now()
#  updated_at           | timestamp with time zone |
#  template             | text                     | NOT NULL
#  transport_type       | text                     | NOT NULL
#  transport_service    | text                     | NOT NULL
#  transport_message_id | text                     |
#  to                   | text                     | NOT NULL
#  recipient_id         | integer                  |
#  extra_fields         | jsonb                    | NOT NULL DEFAULT '{}'::jsonb
#  sent_at              | timestamp with time zone |
#  aborted_at           | timestamp with time zone |
#  template_language    | text                     | NOT NULL DEFAULT ''::text
# Indexes:
#  message_deliveries_pkey                     | PRIMARY KEY btree (id)
#  message_deliveries_transport_message_id_key | UNIQUE btree (transport_message_id)
#  message_deliveries_recipient_id_index       | btree (recipient_id)
#  message_deliveries_sent_at_index            | btree (sent_at)
# Foreign key constraints:
#  message_deliveries_recipient_id_fkey | (recipient_id) REFERENCES members(id) ON DELETE SET NULL
# Referenced By:
#  message_bodies | message_bodies_delivery_id_fkey | (delivery_id) REFERENCES message_deliveries(id) ON DELETE CASCADE
# ---------------------------------------------------------------------------------------------------------------------
