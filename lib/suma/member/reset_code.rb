# frozen_string_literal: true

require "securerandom"

require "suma/postgres"
require "suma/member"
require "suma/messages/verification"

class Suma::Member::ResetCode < Suma::Postgres::Model(:member_reset_codes)
  class Unusable < RuntimeError; end

  plugin :timestamps

  many_to_one :member, class: Suma::Member
  many_to_one :message_delivery, class: "Suma::Message::Delivery"

  dataset_module do
    def usable
      return self.where(Sequel[used: false, canceled: false] & Sequel.expr { expire_at > Time.now })
    end
  end

  def self.replace_active(member, transport:, **options)
    self.db.transaction do
      member.reset_codes_dataset.where(transport:).usable.each(&:expire!)
      return self.create(member:, transport:, **options)
    end
  end

  # Invoke the given block with the reset code referred to by token.
  # Raise Unusable if code is unusable.
  def self.use_code_with_token(token)
    raise LocalJumpError unless block_given?

    code = self.usable[token:]
    raise Unusable unless code&.usable?

    code.db.transaction do
      code.use!
      yield(code)
    end
  end

  def initialize(*)
    super
    self.token ||= Array.new(6) { rand(0..9) }.join
    self.expire_at ||= 15.minutes.from_now
  end

  def expire!
    self.update(expire_at: Time.now, canceled: true)
    return self
  end

  def expired? = self.expire_at < Time.now

  def use!
    self.member.reset_codes_dataset.usable.exclude(id: self.id).each(&:expire!)
    self.update(used: true, expire_at: Time.now)
    return self
  end

  def used? = self.used

  def usable?
    return false if self.used?
    return !self.expired?
  end

  def canceled? = self.canceled

  def dispatch_message
    msg = Suma::Messages::Verification.new(self)
    msg.language = self.member.message_preferences!.preferred_language
    self.message_delivery = case self.transport
      when "sms"
        msg.dispatch_sms(self.member)
      when "email"
        msg.dispatch_email(self.member)
      else
        raise ArgumentError, "Unknown transport for #{self.inspect}"
    end
    self.save_changes
  end

  #
  # :section: Sequel Validation
  #

  def validate
    super
    self.validates_includes(["sms", "email"], :transport)
  end
end

# Table: member_reset_codes
# ------------------------------------------------------------------------------------------------------
# Columns:
#  id                  | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at          | timestamp with time zone | NOT NULL DEFAULT now()
#  updated_at          | timestamp with time zone |
#  transport           | text                     | NOT NULL
#  token               | text                     | NOT NULL
#  used                | boolean                  | NOT NULL DEFAULT false
#  expire_at           | timestamp with time zone | NOT NULL
#  member_id           | integer                  | NOT NULL
#  message_delivery_id | integer                  |
#  canceled            | boolean                  | DEFAULT false
# Indexes:
#  member_reset_codes_pkey            | PRIMARY KEY btree (id)
#  member_reset_codes_member_id_index | btree (member_id)
# Foreign key constraints:
#  member_reset_codes_member_id_fkey           | (member_id) REFERENCES members(id) ON DELETE CASCADE
#  member_reset_codes_message_delivery_id_fkey | (message_delivery_id) REFERENCES message_deliveries(id)
# ------------------------------------------------------------------------------------------------------
