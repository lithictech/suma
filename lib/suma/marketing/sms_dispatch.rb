# frozen_string_literal: true

require "suma/external_links"
require "suma/marketing"
require "suma/postgres/model"

class Suma::Marketing::SmsDispatch < Suma::Postgres::Model(:marketing_sms_dispatches)
  include Suma::Postgres::HybridSearch
  include Suma::AdminLinked
  include Suma::ExternalLinks

  plugin :hybrid_search
  plugin :timestamps

  many_to_one :member, class: "Suma::Member"
  many_to_one :sms_broadcast, class: "Suma::Marketing::SmsBroadcast"

  dataset_module do
    def pending = self.where(sent_at: nil)
  end

  class << self
    def send_all
      Suma::Postgres.check_transaction(
        self.db,
        "cannot send sms while in a transaction due to potential progress loss",
      )
      if Suma::Signalwire.marketing_number.blank?
        self.logger.info("sms_dispatch_no_marketing_number")
        self.dataset.pending.each do |dispatch|
          dispatch.cancel
          dispatch.save_changes
        end
        return
      end
      marketing_number = Suma::PhoneNumber.format_e164(Suma::Signalwire.marketing_number)
      self.dataset.pending.each do |dispatch|
        body = dispatch.sms_broadcast.render(member: dispatch.member, language: nil)
        if body.blank?
          dispatch.cancel.save_changes
          next
        end
        begin
          sw_resp = Suma::Signalwire.send_sms(
            marketing_number,
            Suma::PhoneNumber.format_e164(dispatch.member.phone),
            body,
          )
        rescue Twilio::REST::RestError => e
          tags = {
            member_id: dispatch.member.id,
            member_name: dispatch.member.name,
            broadcast_id: dispatch.sms_broadcast.id,
            broadcast: dispatch.sms_broadcast.label,
          }
          self.logger.error("dispatch_marketing_broadcast_error", tags, e)
          Sentry.capture_exception(e, tags:)
          next
        end
        self.logger.info(
          "dispatched_marketing_broadcast",
          member_id: dispatch.member.id,
          broadcast: dispatch.sms_broadcast.label,
          signalwire_message_id: sw_resp.sid,
        )
        dispatch.set_sent(sw_resp.sid)
        dispatch.save_changes
      end
    end
  end

  def status
    return :canceled if self.sent_at && self.transport_message_id == ""
    return :sent if self.sent_at
    return :pending
  end

  def sent? = self.status == :sent
  def pending? = self.status == :pending
  def canceled? = self.status == :canceled
  def can_cancel? = self.status == :pending

  def set_sent(transport_message_id, at: Time.now)
    raise ArgumentError, "transport_message_id must be present" if transport_message_id.blank?
    self.sent_at = at
    self.transport_message_id = transport_message_id
    self.last_error = nil
    return self
  end

  def cancel(at: Time.now)
    self.sent_at = at
    self.transport_message_id = ""
    return self
  end

  def rel_admin_link = "/marketing-sms-dispatch/#{self.id}"

  def hybrid_search_fields
    return [
      :member,
      :sms_broadcast,
      :sent_at,
      :transport_message_id,
      :last_error,
      :status,
    ]
  end

  def _external_links_self
    return [] if self.transport_message_id.blank?
    return [
      self._external_link(
        "Signalwire Message",
        Suma::Signalwire.message_log_url(self.transport_message_id),
      ),
    ]
  end
end

# Table: marketing_sms_dispatches
# -----------------------------------------------------------------------------------------------------------------------------------------------------------
# Columns:
#  id                   | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at           | timestamp with time zone | NOT NULL DEFAULT now()
#  member_id            | integer                  | NOT NULL
#  sms_broadcast_id     | integer                  | NOT NULL
#  sent_at              | timestamp with time zone |
#  transport_message_id | text                     |
#  last_error           | text                     |
#  search_content       | text                     |
#  search_embedding     | vector(384)              |
#  search_hash          | text                     |
# Indexes:
#  marketing_sms_dispatches_pkey                           | PRIMARY KEY btree (id)
#  marketing_sms_dispatches_member_id_sms_broadcast_id_key | UNIQUE btree (member_id, sms_broadcast_id)
#  marketing_sms_dispatches_search_content_tsvector_index  | gin (to_tsvector('english'::regconfig, search_content))
# Check constraints:
#  sent_at_transport_message_id_set_together | (sent_at IS NULL AND transport_message_id IS NULL OR sent_at IS NOT NULL AND transport_message_id IS NOT NULL)
# Foreign key constraints:
#  marketing_sms_dispatches_member_id_fkey        | (member_id) REFERENCES members(id)
#  marketing_sms_dispatches_sms_broadcast_id_fkey | (sms_broadcast_id) REFERENCES marketing_sms_broadcasts(id)
# -----------------------------------------------------------------------------------------------------------------------------------------------------------
