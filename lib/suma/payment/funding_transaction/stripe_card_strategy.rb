# frozen_string_literal: true

require "suma/stripe"
require "suma/payment/funding_transaction/strategy"
require "suma/postgres/model"

class Suma::Payment::FundingTransaction::StripeCardStrategy <
  Suma::Postgres::Model(:payment_funding_transaction_stripe_card_strategies)
  include Suma::Payment::FundingTransaction::Strategy

  one_to_one :funding_transaction, class: "Suma::Payment::FundingTransaction"
  many_to_one :originating_card, class: "Suma::Payment::Card"

  def originating_instrument
    return self.originating_card
  end

  def short_name
    return "Stripe Card Funding"
  end

  def check_validity
    card = self.originating_card
    result = []
    (result << "is soft deleted and cannot be used for funding") if card.soft_deleted?
    raise Suma::InvalidPrecondition, "card is not owned by a member, should only see this in tests" if card.member.nil?
    (result << "member is not registered in Stripe") unless card.member.stripe.registered_as_customer?
    return result
  end

  def ready_to_collect_funds?
    return true
  end

  def charge_id = self.charge_json&.fetch("id")

  def collect_funds
    return false if self.charge_id.present?
    charge = self.originating_card.member.stripe.charge_card(
      card: self.originating_card,
      amount: self.funding_transaction.amount,
      memo: "#{Suma.operator_name} charge",
      idempotency_key: Suma.idempotency_key(self, "charge"),
      params: {capture: false},
      metadata: {suma_funding_transaction_id: self.funding_transaction.id},
    )
    self.charge_json = charge.as_json
    charge_id_set!
    return true
  end

  def funds_cleared?
    raise Suma::InvalidPrecondition, "charge_json must be set" if self.charge_json.nil?
    return true if self.charge_json["captured"]
    charge = Stripe::Charge.capture(self.charge_id)
    self.charge_json = charge.as_json
    charge_id_set!
    return true
  end

  private def charge_id_set!
    return if self.charge_id.present?
    msg = "Stripe charge idid not set after API call from #{self.class.name}[#{self.id}]. " \
          "JSON: #{self.charge_json}"
    raise Suma::InvalidPostcondition, msg
  end

  def _external_links_self
    return [] unless self.charge_id
    return [
      self._external_link(
        "Stripe Charge",
        "#{Suma::Stripe.app_url}/payments/#{self.charge_id}",
      ),
    ]
  end

  def _external_link_deps
    return [self.originating_card]
  end
end

# Table: payment_funding_transaction_stripe_card_strategies
# ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Columns:
#  id                  | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at          | timestamp with time zone | NOT NULL DEFAULT now()
#  updated_at          | timestamp with time zone |
#  originating_card_id | integer                  | NOT NULL
#  charge_json         | jsonb                    |
# Indexes:
#  payment_funding_transaction_stripe_card_strategies_pkey | PRIMARY KEY btree (id)
# Foreign key constraints:
#  payment_funding_transaction_stripe_car_originating_card_id_fkey | (originating_card_id) REFERENCES payment_cards(id)
# Referenced By:
#  payment_funding_transactions | payment_funding_transactions_stripe_card_strategy_id_fkey | (stripe_card_strategy_id) REFERENCES payment_funding_transaction_stripe_card_strategies(id)
# ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
