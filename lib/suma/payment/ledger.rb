# frozen_string_literal: true

require "suma/admin_linked"
require "suma/payment"

class Suma::Payment::Ledger < Suma::Postgres::Model(:payment_ledgers)
  include Suma::AdminLinked

  plugin :timestamps
  plugin :translated_text, :contribution_text, Suma::TranslatedText

  many_to_one :account, class: "Suma::Payment::Account"
  many_to_many :vendor_service_categories,
               class: "Suma::Vendor::ServiceCategory",
               join_table: :vendor_service_categories_payment_ledgers,
               left_key: :ledger_id,
               right_key: :category_id
  one_to_many :originated_book_transactions, class: "Suma::Payment::BookTransaction", key: :originating_ledger_id
  one_to_many :received_book_transactions, class: "Suma::Payment::BookTransaction", key: :receiving_ledger_id
  one_to_many :combined_book_transactions,
              class: "Suma::Payment::BookTransaction",
              readonly: true,
              eager_loader: (lambda do |eo|
                # Custom eager loader because we need to check 2 FKs for an ID, not just one.
                assocs_by_ledger_id = {}
                eo[:rows].each do |r|
                  arr = []
                  assocs_by_ledger_id[r.id] = arr
                  r.associations[:combined_book_transactions] = arr
                end
                ids = eo[:id_map].keys
                Suma::Payment::BookTransaction.
                  where(Sequel[originating_ledger_id: ids] | Sequel[receiving_ledger_id: ids]).
                  order(Sequel.desc(:apply_at), Sequel.desc(:id)).all do |bt|
                  [:originating_ledger_id, :receiving_ledger_id].each do |k|
                    arr = assocs_by_ledger_id[bt[k]]
                    arr << bt if arr
                  end
                end
                assocs_by_ledger_id.each_value(&:uniq!)
              end) do |_ds|
    # Custom block for when we aren't using eager loading
    Suma::Payment::BookTransaction.
      where(Sequel[originating_ledger_id: id] | Sequel[receiving_ledger_id: id]).
      order(Sequel.desc(:apply_at), Sequel.desc(:id))
  end

  def balance
    credits = self.received_book_transactions.sum(Money.new(0), &:amount)
    debits = self.originated_book_transactions.sum(Money.new(0), &:amount)
    return credits - debits
  end

  # Return true if this ledger can be used to purchase the given service.
  # This is done by comparing the vendor service categories on each.
  # If any of the VSCs for the service appear in ledger's VSC graph
  # (all its VSCs and descendants), we say the ledger can be used
  # to pay for the service
  # (whether the ledger has balance is checked separately).
  #
  # For example, given the VSC tree:
  # food -> grocery -> organic
  #                 -> packaged
  #      -> restaurant
  #
  # If a ledger has "food" assigned to it,
  # the VSC graph includes all of the above nodes.
  # any vendor services with these categories (grocery, packaged, etc)
  # can be purchased by this ledger.
  #
  # If the ledger had 'organic' assigned,
  # only vendor services with 'organic' assigned could be used.
  #
  # Note that ledgers and services can have multiple service categories.
  def can_be_used_to_purchase?(has_vnd_svc_categories)
    match = self.category_used_to_purchase(has_vnd_svc_categories)
    return !match.nil?
  end

  # See can_be_used_to_purchase?. Returns the first matching category
  # which qualifies this ledger to pay for the vendor service.
  # We may need to refind this search algorithm in the future
  # if we find it doesn't select the right category.
  def category_used_to_purchase(has_vnd_svc_categories)
    service_cat_ids = has_vnd_svc_categories.vendor_service_categories.map(&:id)
    return self.vendor_service_categories.find do |c|
      chain_ids = c.tsort.map(&:id)
      !(service_cat_ids & chain_ids).empty?
    end
  end

  def rel_admin_link = self.account.rel_admin_link

  def admin_label
    lbl = "#{self.account.display_name} - #{self.name}"
    lbl = "(#{self.id}) #{lbl}" unless self.account.platform_account?
    return lbl
  end

  def search_label
    return self.admin_label
  end
end

# Table: payment_ledgers
# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# Columns:
#  id         | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at | timestamp with time zone | NOT NULL DEFAULT now()
#  updated_at | timestamp with time zone |
#  currency   | text                     | NOT NULL
#  name       | text                     | NOT NULL
#  account_id | integer                  |
# Indexes:
#  payment_ledgers_pkey                | PRIMARY KEY btree (id)
#  payment_ledgers_account_id_name_key | UNIQUE btree (account_id, name)
#  payment_ledgers_account_id_index    | btree (account_id)
# Foreign key constraints:
#  payment_ledgers_account_id_fkey | (account_id) REFERENCES payment_accounts(id)
# Referenced By:
#  payment_book_transactions                 | payment_book_transactions_originating_ledger_id_fkey     | (originating_ledger_id) REFERENCES payment_ledgers(id)
#  payment_book_transactions                 | payment_book_transactions_receiving_ledger_id_fkey       | (receiving_ledger_id) REFERENCES payment_ledgers(id)
#  payment_funding_transactions              | payment_funding_transactions_platform_ledger_id_fkey     | (platform_ledger_id) REFERENCES payment_ledgers(id) ON DELETE RESTRICT
#  vendor_service_categories_payment_ledgers | vendor_service_categories_payment_ledgers_ledger_id_fkey | (ledger_id) REFERENCES payment_ledgers(id)
# ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
