# frozen_string_literal: true

require "suma/postgres/model"
require "suma/support"

class Suma::Support::Note < Suma::Postgres::Model(:support_notes)
  many_to_one :creator, class: "Suma::Member"
  many_to_one :editor, class: "Suma::Member"

  many_to_many :organization_membership_verifications,
               class: "Suma::Organization::Membership::Verification",
               join_table: :support_notes_organization_membership_verifications,
               left_key: :note_id,
               right_key: :verification_id

  many_to_many :members,
               class: "Suma::Member",
               join_table: :support_notes_members,
               left_key: :note_id,
               right_key: :member_id

  class << self
    def combine_datasets(*exprs)
      ds = self.reduce_expr(:|, exprs)
      ds = ds.order(Sequel.desc(Sequel.function(:coalesce, :edited_at, :created_at)), :id)
      return ds
    end

    def combine_instances(*arrays)
      notes = [].concat(*arrays)
      notes.sort_by! { |n| [n.authored_at, -n.id] }
      notes.reverse!
      return notes
    end
  end

  # Return content rendered as markdown html.
  # It will have no container paragraph element, to make it easier to nest.
  def content_html
    c = self.content_md
    s = Suma::I18n::Formatter.redcarpet.render(c)
    return Suma::I18n::Formatter.strip_paragraph_container!(s)
  end

  # Convert the content into markdown, which may require some processing for convenience
  # (like turning raw urls into markdown urls).
  def content_md
    c = self.content
    start_of_string_regex = %r{^https?://\S+}
    c = c.gsub(start_of_string_regex) do |url|
      # Since this is the start of the string, we can just format as markdown.
      "[#{url}](#{url})"
    end

    in_string_regex = %r{\shttps?://\S+}
    c = c.gsub(in_string_regex) do |match|
      # The leading character is a space; remove it from the url and prepend it before the markdown link.
      # We do not have matchdata available so cannot use capture groups.
      url = match[1..]
      "#{match[0]}[#{url}](#{url})"
    end
    return c
  end

  def author = self.editor || self.creator
  def authored_at = self.edited_at || self.created_at

  def before_create
    self.creator ||= Suma.request_user_and_admin[1]
    self.created_at ||= Time.now
    super
  end

  def before_update
    if self.changed_columns.include?(:content)
      self.editor = Suma.request_user_and_admin[1]
      self.edited_at = Time.now
    end
    super
  end
end

# Table: organization_membership_verification_notes
# -----------------------------------------------------------------------------------------------------------------------------------------------------------
# Columns:
#  id              | integer                  | PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY
#  created_at      | timestamp with time zone | NOT NULL DEFAULT now()
#  edited_at       | timestamp with time zone |
#  content         | text                     | NOT NULL
#  verification_id | integer                  | NOT NULL
#  creator_id      | integer                  |
#  editor_id       | integer                  |
# Indexes:
#  organization_membership_verification_notes_pkey                 | PRIMARY KEY btree (id)
#  organization_membership_verification_notes_verification_id_inde | btree (verification_id)
# Foreign key constraints:
#  organization_membership_verification_notes_creator_id_fkey      | (creator_id) REFERENCES members(id) ON DELETE SET NULL
#  organization_membership_verification_notes_editor_id_fkey       | (editor_id) REFERENCES members(id) ON DELETE SET NULL
#  organization_membership_verification_notes_verification_id_fkey | (verification_id) REFERENCES organization_membership_verifications(id) ON DELETE CASCADE
# -----------------------------------------------------------------------------------------------------------------------------------------------------------
